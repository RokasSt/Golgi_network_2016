'''
Neuron simulator export for:

Components:
    MFSpikeSyn (Type: expThreeSynapse:  tauRise=1.0E-4 (SI time) tauDecay1=7.0E-4 (SI time) tauDecay2=0.0025 (SI time) peakTime1=2.270228507231199E-4 (SI time) waveformFactor1=1.61360214664657 (dimensionless) peakTime2=3.3529956509043755E-4 (SI time) waveformFactor2=1.1911769125863751 (dimensionless) gbase1=7.0E-10 (SI conductance) gbase2=2.0000000000000003E-10 (SI conductance) erev=0.0 (SI voltage))
    pulseGen0 (Type: pulseGenerator:  delay=0.05 (SI time) duration=0.5 (SI time) amplitude=1.5E-11 (SI current))
    iaf1 (Type: iafCell:  leakConductance=5.0E-10 (SI conductance) leakReversal=-0.06 (SI voltage) thresh=-0.035 (SI voltage) reset=-0.065 (SI voltage) C=1.0000000000000001E-11 (SI capacitance))
    iaf2 (Type: iafCell:  leakConductance=5.2E-10 (SI conductance) leakReversal=-0.06 (SI voltage) thresh=-0.035 (SI voltage) reset=-0.07 (SI voltage) C=1.0000000000000001E-11 (SI capacitance))
    net2 (Type: network)
    sim1 (Type: Simulation:  length=3.0 (SI time) step=5.0E-6 (SI time))


    This NEURON file has been generated by org.neuroml.export (see https://github.com/NeuroML/org.neuroml.export)
         org.neuroml.export  v1.4.4
         org.neuroml.model   v1.4.4
         jLEMS               v0.9.8.4

'''

import neuron

import time
h = neuron.h
h.load_file("nrngui.hoc")

h("objref p")
h("p = new PythonObject()")

# Adding simulation Component(id=sim1 type=Simulation) of network/component: net2 (Type: network)
print("Population Pop0 contains 1 instance(s) of component: iaf1 of type: iafCell")

h(" {n_Pop0 = 1} ")
'''
Population Pop0 contains instances of Component(id=iaf1 type=iafCell)
whose dynamics will be implemented as a mechanism (iaf1) in a mod file
'''
h(" create Pop0[1]")
h(" objectvar m_iaf1_Pop0[1] ")

for i in range(int(h.n_Pop0)):
    h.Pop0[i].L = 10.0
    h.Pop0[i](0.5).diam = 10.0
    h.Pop0[i](0.5).cm = 3.183098861837907
    h.Pop0[i].push()
    h(" Pop0[%i]  { m_iaf1_Pop0[%i] = new iaf1(0.5) } "%(i,i))

    h.m_iaf1_Pop0[i].leakConductance = 4.9999997E-4
    h.m_iaf1_Pop0[i].leakReversal = -60.0
    h.m_iaf1_Pop0[i].thresh = -35.0
    h.m_iaf1_Pop0[i].reset = -65.0
    h.m_iaf1_Pop0[i].C = 1.0E-5
    h.pop_section()
print("Population Pop1 contains 1 instance(s) of component: iaf2 of type: iafCell")

h(" {n_Pop1 = 1} ")
'''
Population Pop1 contains instances of Component(id=iaf2 type=iafCell)
whose dynamics will be implemented as a mechanism (iaf2) in a mod file
'''
h(" create Pop1[1]")
h(" objectvar m_iaf2_Pop1[1] ")

for i in range(int(h.n_Pop1)):
    h.Pop1[i].L = 10.0
    h.Pop1[i](0.5).diam = 10.0
    h.Pop1[i](0.5).cm = 3.183098861837907
    h.Pop1[i].push()
    h(" Pop1[%i]  { m_iaf2_Pop1[%i] = new iaf2(0.5) } "%(i,i))

    h.m_iaf2_Pop1[i].leakConductance = 5.2E-4
    h.m_iaf2_Pop1[i].leakReversal = -60.0
    h.m_iaf2_Pop1[i].thresh = -35.0
    h.m_iaf2_Pop1[i].reset = -70.0
    h.m_iaf2_Pop1[i].C = 1.0E-5
    h.pop_section()
# Adding projection: projection1, from Pop0 to Pop1 with synapse MFSpikeSyn, 1 connection(s)
h("objectvar syn_projection1_MFSpikeSyn[1]")

# Connection null: 0, seg 0 (0.500000) -> 0, seg 0 (0.500000)
h("Pop1[0] syn_projection1_MFSpikeSyn[0] = new MFSpikeSyn(0.500000)")
h("objectvar nc_syn_projection1_MFSpikeSyn_0")
h("Pop0[0] nc_syn_projection1_MFSpikeSyn_0 = new NetCon(&v(0.5), syn_projection1_MFSpikeSyn[0], -35.000000, 0.0, 1.0)")  

# Adding input: Component(id=0 type=input)

h("objectvar stimInput_0")
h("Pop0[0] { stimInput_0 = new pulseGen0(0.500000) } ")

trec = h.Vector()
trec.record(h._ref_t)

h.tstop = 3000

h.dt = 0.005

h.steps_per_ms = 200.0

# Display: display_d2
display_d2 = h.Graph(0)
display_d2.size(0,h.tstop,-80.0,50.0)
display_d2.view(0, -80.0, h.tstop, 130.0, 80, 330, 330, 250)
h.graphList[0].append(display_d2)
# Line, plotting: Pop0[0]/v
display_d2.addexpr("Pop0[0].v(0.5)", "Pop0[0].v(0.5)", 1, 1, 0.8, 0.9, 2)
# Line, plotting: Pop1[0]/v
display_d2.addexpr("Pop1[0].v(0.5)", "Pop1[0].v(0.5)", 2, 1, 0.8, 0.9, 2)



# File to save: time
# Column: time
h(' objectvar v_time ')
h(' { v_time = new Vector() } ')
h(' v_time.record(&t) ')
h.v_time.resize((h.tstop * h.steps_per_ms) + 1)



h.nrncontrolmenu()
sim_start = time.time()
print("Running a simulation of %sms (dt = %sms)" % (h.tstop, h.dt))

h.run()

sim_end = time.time()
sim_time = sim_end - sim_start
print("Finished simulation in %f seconds (%f mins), saving results..."%(sim_time, sim_time/60.0))

display_d2.exec_menu("View = plot")

# File to save: time
py_v_time = [ t/1000 for t in h.v_time.to_python() ]  # Convert to Python list for speed...

f_time_f2 = open('time.dat', 'w')
for i in range(int(h.tstop * h.steps_per_ms) + 1):
    f_time_f2.write('%f'% py_v_time[i])  # Save in SI units...+ '\n')
f_time_f2.close()
print("Saved data to: time.dat")

save_end = time.time()
save_time = save_end - sim_end
print("Finished saving results in %f seconds"%(save_time))

print("Done")

